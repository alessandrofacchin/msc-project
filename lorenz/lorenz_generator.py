from __future__ import annotations
from typing import Tuple
from scipy.integrate import solve_ivp
from numpy import arange
import numpy as np


class LorenzGenerator(object):

    _sigma: float = 10
    _rho: float = 28
    _beta: float = 8/3

    def __init__(self, sigma: float=None, rho: float=None, beta: float=None):
        """Lorenz Generator

        Args:
            sigma (float, optional): Lorenz attractor's sigma. Defaults to 10, as in LFADS.
            rho (float, optional): Lorenz attractor's rho. Defaults to 28, as in LFADS.
            beta (float, optional): Lorenz attractor's beta. Defaults to 2.667, as in LFADS.
        """
        self.sigma: float = sigma if sigma is not None else self._sigma
        self.rho: float = rho if rho is not None else self._rho
        self.beta: float = beta if beta is not None else self._beta
        
    def step(self, t: float, point: Tuple[float, float, float]) -> Tuple[float, float, float]:
        """Lorenz System single step

        Args:
            point (Tuple[float, float, float]): coordinates of the point

        Returns:
            Tuple[float, float, float]: The next point
        """
        x, y, z = point
        x_dot = self.sigma * (y - x)
        y_dot = self.rho * x - y - x * z
        z_dot = x * y - self.beta * z
        return (x_dot, y_dot, z_dot)

    def generate_latent(self, x0: float=0, y0: float=1, z0: float=1.05, 
    start: float=0, stop: float=1, step: float=0.006) -> Tuple[np.ndarray, np.ndarray]:
        """Generates the latent variables
        It uses the Lorenz system and integrates with the Explicit Runge-Kutta method of order 5(4).

        Args:
            x0 (float, optional): Initial point X coordinate. Defaults to 0.
            y0 (float, optional): Initial point Y coordinate. Defaults to 1.
            z0 (float, optional): Initial point Z coordinate. Defaults to 1.05.
            start (float, optional): Starting time. Defaults to 0.
            stop (float, optional): Terminal time. Defaults to 1, as in LFADS.
            step (float, optional): Time step. Defaults to 0.006, as in LFADS.

        Returns:
            Tuple[np.ndarray, np.ndarray]: Time vector (T,) and matrix of latent variables (T,3).
        """
        
        soln = solve_ivp(lambda t, point: self.step(t, point), (start, stop), (x0, y0, z0),
                 dense_output=True)
        t = list(arange(start, stop, step))
        x, y, z = soln.sol(t)
        return np.array(t), np.array([x,y,z]).transpose()

    def generate_firing_rates(self, n: int=30, baseline: float=5, x0: float=0, y0: float=1, z0: float=1.05, 
    start: float=0, stop: float=1, step: float=0.006) -> Tuple[np.ndarray, np.ndarray]:
        """Generate the firing rates
        It converts the latent variables generated by the Lorenz system into firing rates

        Args:
            n (int, optional): Total number of neurons. Defaults to 30, as in LFADS.
            baseline (float, optional): Baseline firing rate (Hz). Defaults to 5, as in LFADS.
            x0 (float, optional): Initial point X coordinate. Defaults to 0.
            y0 (float, optional): Initial point Y coordinate. Defaults to 1.
            z0 (float, optional): Initial point Z coordinate. Defaults to 1.05.
            start (float, optional): Starting time. Defaults to 0.
            stop (float, optional): Terminal time. Defaults to 1, as in LFADS.
            step (float, optional): Time step. Defaults to 0.006, as in LFADS.

        Returns:
            Tuple[np.ndarray, np.ndarray]: Time vector (T,) and matrix of latent variables (T,3).
        """

        t, Z = self.generate_latent(x0=x0, y0=y0, z0=z0, start=start, stop=stop, step=step)

        NotImplementedError('Still working on this')